{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","assembly/__tests__/example.spec.ts","assembly/index.ts","node_modules/@as-pect/assembly/assembly/internal/Expectation.ts","~lib/util/error.ts","~lib/rt.ts","~lib/memory.ts","~lib/util/memory.ts","node_modules/@as-pect/assembly/assembly/internal/Actual.ts","node_modules/@as-pect/assembly/assembly/internal/Reflect.ts","~lib/util/hash.ts","~lib/set.ts","node_modules/@as-pect/assembly/assembly/internal/ReflectedValueType.ts","~lib/arraybuffer.ts","~lib/map.ts","node_modules/@as-pect/assembly/assembly/internal/Expected.ts","node_modules/@as-pect/assembly/assembly/internal/assert.ts","node_modules/@as-pect/assembly/assembly/internal/noOp.ts","node_modules/@as-pect/assembly/assembly/internal/log.ts","node_modules/@as-pect/assembly/assembly/internal/call.ts","~lib/function.ts"],"names":[],"mappings":"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","sourceRoot":"./output.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - 2 * BLOCK_OVERHEAD;\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  var root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  var memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n  var blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  var newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy var white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy var total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy var state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var iter: Object; // null\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    var rtId = this.rtId;\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    var next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    var prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  var pn = pinSpace;\n  var iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  var ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  var obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  var ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  var newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  var child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy var threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  var budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\"└ GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\"└ GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","import { test } from \"../index\";\n\ndescribe(\"example\", () => {\n  it(\"should execute successfully\", () => {\n    expect<bool>(test(\"this is my test\", () => {})).toBeTruthy();\n  });\n});\n","// TODO: pass the name parameter to Rust for logging\nexport function test(_name: string, f: () => void): bool {\n  f();\n  return true;\n}","import { toIncludeComparison } from \"./comparison/toIncludeComparison\";\r\nimport { toIncludeEqualComparison } from \"./comparison/toIncludeEqualComparison\";\r\nimport { Actual } from \"./Actual\";\r\nimport { Expected } from \"./Expected\";\r\nimport { assert } from \"./assert\";\r\n\r\n// @ts-ignore: Decorators *are* valid here\r\n@external(\"__aspect\", \"tryCall\")\r\ndeclare function tryCall(func: () => void): bool;\r\n\r\n// @ts-ignore: Decorators *are* valid here\r\n@global\r\nexport class Expectation<T> {\r\n  /**\r\n   * This i32 is set to 1 if the expectation is negated. Using the _not (xor) condition assertion\r\n   * makes assertions very easy to write and understand.\r\n   */\r\n  _not: i32 = 0;\r\n\r\n  actual: T;\r\n\r\n  constructor(actual: T) {\r\n    this.actual = actual;\r\n  }\r\n\r\n  public get not(): Expectation<T> {\r\n    this._not = 1;\r\n    return this;\r\n  }\r\n\r\n  public toBe(expected: T, message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    let equals = i32(actual == expected);\r\n    let negated = this._not;\r\n\r\n    Actual.report(actual);\r\n\r\n    if (isReference(actual) && !isFunction(actual)) {\r\n      if (\r\n        !negated &&\r\n        changetype<usize>(actual) !== 0 &&\r\n        changetype<usize>(expected) !== 0 &&\r\n        Reflect.equals(actual, expected) == Reflect.SUCCESSFUL_MATCH\r\n      ) {\r\n        Expected.report(\"Serializes to same value.\", 0);\r\n      } else {\r\n        Expected.report(expected, negated);\r\n      }\r\n    } else {\r\n      Expected.report(expected, negated);\r\n    }\r\n\r\n    // The assertion is either the items equal, or the expectation is negated\r\n    assert(equals ^ negated, message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toStrictEqual(expected: T, message: string = \"\"): void {\r\n    let result = Reflect.FAILED_MATCH;\r\n    result = Reflect.equals(this.actual, expected);\r\n\r\n    let equals = i32(result == Reflect.SUCCESSFUL_MATCH);\r\n    Actual.report(this.actual);\r\n    Expected.report(expected);\r\n\r\n    assert(equals ^ this._not, message);\r\n\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toBlockEqual(expected: T, message: string = \"\"): void {\r\n    WARNING(\r\n      \"toBlockEqual has been deprecated and results in a toStrictEqual call.\",\r\n    );\r\n    this.toStrictEqual(expected, message);\r\n  }\r\n\r\n  public toBeTruthy(message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    Actual.report(actual);\r\n    let negated = this._not;\r\n    Expected.reportTruthy(negated);\r\n\r\n    if (isReference(actual)) {\r\n      if (actual instanceof String) {\r\n        let truthy = i32(\r\n          changetype<usize>(actual) != 0 &&\r\n            changetype<string>(actual).length > 0,\r\n        );\r\n        assert(truthy ^ negated, message);\r\n      } else {\r\n        let truthy = i32(changetype<usize>(actual) != 0);\r\n        assert(truthy ^ negated, message);\r\n      }\r\n    } else {\r\n      if (isFloat(actual)) {\r\n        let truthy = i32(!isNaN(actual) && actual != 0.0);\r\n        assert(truthy ^ negated, message);\r\n      } else if (isInteger(actual)) {\r\n        let truthy = i32(actual != 0);\r\n        assert(truthy ^ negated, message);\r\n      }\r\n    }\r\n\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toBeFalsy(message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    Actual.report(actual);\r\n    let negated = this._not;\r\n    Expected.reportFalsy(negated);\r\n\r\n    if (isReference(actual)) {\r\n      // strings require an extra length check\r\n      if (actual instanceof String) {\r\n        let falsy = i32(\r\n          changetype<usize>(actual) == 0 ||\r\n            changetype<string>(actual).length == 0,\r\n        );\r\n        assert(falsy ^ negated, message);\r\n      } else {\r\n        let falsy = i32(changetype<usize>(actual) == 0);\r\n        assert(falsy ^ negated, message);\r\n      }\r\n    } else {\r\n      if (isFloat(actual)) {\r\n        // @ts-ignore: actual is a float value\r\n        let falsy = i32(isNaN(actual) || actual == 0.0);\r\n        assert(falsy ^ negated, message);\r\n      } else if (isInteger(actual)) {\r\n        let falsy = i32(actual == 0);\r\n        assert(falsy ^ negated, message);\r\n      }\r\n    }\r\n\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toThrow(message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    let negated = this._not;\r\n\r\n    if (!isFunction(this.actual))\r\n      ERROR(\r\n        \"Expectation#toThrow assertion called on actual T where T is not a function reference\",\r\n      );\r\n    if (idof<T>() != idof<() => void>())\r\n      ERROR(\r\n        \"Expectation#toThrow assertion called on actual T where T is not a function reference with signature () => void\",\r\n      );\r\n\r\n    // @ts-ignore: safe tryCall\r\n    let throws = i32(!tryCall(actual));\r\n    Actual.report(throws ? \"Throws\" : \"Not Throws\");\r\n    Expected.report(\"Throws\", negated);\r\n    assert(negated ^ throws, message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toBeGreaterThan(expected: T, message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    let negated = this._not;\r\n    Actual.report(actual);\r\n    Expected.report(expected, negated);\r\n\r\n    if (!isDefined(actual > expected))\r\n      ERROR(\r\n        \"Invalid call to toBeGreaterThan. Generic type T must have an operator implemented for the greaterThan (>) operation.\",\r\n      );\r\n\r\n    if (isReference(actual)) {\r\n      // Perform reference type null checks\r\n      assert(\r\n        i32(changetype<usize>(expected) != 0),\r\n        \"Value comparison fails, expected value is null.\",\r\n      );\r\n      assert(\r\n        i32(changetype<usize>(actual) != 0),\r\n        \"Value comparison fails, actual value is null.\",\r\n      );\r\n    }\r\n\r\n    // Compare float types\r\n    if (isFloat(actual)) {\r\n      assert(\r\n        i32(!isNaN(expected)),\r\n        \"Value comparison fails, expected value is NaN.\",\r\n      );\r\n      assert(\r\n        i32(!isNaN(actual)),\r\n        \"Value comparison fails, actual value is NaN.\",\r\n      );\r\n    }\r\n\r\n    // do actual greater than comparison\r\n    assert(negated ^ i32(actual > expected), message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toBeGreaterThanOrEqual(expected: T, message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    let negated = this._not;\r\n\r\n    Actual.report(actual);\r\n    Expected.report(expected, negated);\r\n\r\n    if (!isDefined(actual >= expected))\r\n      ERROR(\r\n        \"Invalid call to toBeGreaterThanOrEqual. Generic type T must have an operator implemented for the greaterThanOrEqual (>=) operation.\",\r\n      );\r\n\r\n    // null checks\r\n    if (isReference(actual)) {\r\n      assert(\r\n        i32(changetype<usize>(expected) != 0),\r\n        \"Value comparison fails, expected value is null.\",\r\n      );\r\n      assert(\r\n        i32(changetype<usize>(actual) != 0),\r\n        \"Value comparison fails, actual value is null.\",\r\n      );\r\n    }\r\n\r\n    // Compare float types\r\n    if (isFloat(actual)) {\r\n      assert(\r\n        i32(!isNaN(expected)),\r\n        \"Value comparison fails, expected value is NaN.\",\r\n      );\r\n      assert(\r\n        i32(!isNaN(actual)),\r\n        \"Value comparison fails, actual value is NaN.\",\r\n      );\r\n    }\r\n\r\n    // do actual greater than comparison\r\n    assert(negated ^ i32(actual >= expected), message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toBeLessThan(expected: T, message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    let negated = this._not;\r\n    Actual.report(actual);\r\n    Expected.report(expected, negated);\r\n\r\n    if (!isDefined(actual < expected))\r\n      ERROR(\r\n        \"Invalid call to toBeLessThan. Generic type T must have an operator implemented for the lessThan (<) operation.\",\r\n      );\r\n\r\n    // null checks\r\n    if (isReference(actual)) {\r\n      assert(\r\n        i32(changetype<usize>(expected) != 0),\r\n        \"Value comparison fails, expected value is null.\",\r\n      );\r\n      assert(\r\n        i32(changetype<usize>(actual) != 0),\r\n        \"Value comparison fails, actual value is null.\",\r\n      );\r\n    } else if (isFloat(actual)) {\r\n      assert(\r\n        i32(!isNaN(expected)),\r\n        \"Value comparison fails, expected value is NaN.\",\r\n      );\r\n      assert(\r\n        i32(!isNaN(actual)),\r\n        \"Value comparison fails, actual value is NaN.\",\r\n      );\r\n    }\r\n\r\n    // do actual less than comparison\r\n    assert(negated ^ i32(actual < expected), message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toBeLessThanOrEqual(expected: T, message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    let negated = this._not;\r\n    Actual.report(actual);\r\n    Expected.report(expected, negated);\r\n\r\n    if (!isDefined(actual > expected))\r\n      ERROR(\r\n        \"Invalid call to toBeLessThanOrEqual. Generic type T must have an operator implemented for the lessThanOrEqual (<=) operation.\",\r\n      );\r\n\r\n    // null checks\r\n    if (isReference(actual)) {\r\n      assert(\r\n        i32(changetype<usize>(expected) != 0),\r\n        \"Value comparison fails, expected value is null.\",\r\n      );\r\n      assert(\r\n        i32(changetype<usize>(actual) != 0),\r\n        \"Value comparison fails, actual value is null.\",\r\n      );\r\n    }\r\n\r\n    if (isFloat(actual)) {\r\n      assert(\r\n        i32(!isNaN(expected)),\r\n        \"Value comparison fails, expected value is NaN.\",\r\n      );\r\n      assert(\r\n        i32(!isNaN(actual)),\r\n        \"Value comparison fails, actual value is NaN.\",\r\n      );\r\n    }\r\n\r\n    // do actual less than comparison\r\n    assert(negated ^ i32(actual <= expected), message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toBeNull(message: string = \"\"): void {\r\n    let negated = this._not;\r\n    let actual = this.actual;\r\n\r\n    if (actual instanceof usize) {\r\n      Actual.report(actual);\r\n      Expected.report(<usize>0, negated);\r\n      // @ts-ignore: actual is instanceof number type\r\n      assert(negated ^ i32(actual == 0), message);\r\n      Actual.clear();\r\n      Expected.clear();\r\n    } else if (isReference(actual)) {\r\n      Actual.report(actual);\r\n\r\n      Expected.report(changetype<T>(0), negated);\r\n      assert(negated ^ i32(changetype<usize>(actual) == 0), message);\r\n      Actual.clear();\r\n      Expected.clear();\r\n    } else {\r\n      ERROR(\r\n        \"toBeNull assertion must be called with a reference type T or usize.\",\r\n      );\r\n    }\r\n  }\r\n\r\n  public toBeCloseTo(\r\n    expected: T,\r\n    decimalPlaces: i32 = 2,\r\n    message: string = \"\",\r\n  ): void {\r\n    let actual = this.actual;\r\n    let negated = this._not;\r\n\r\n    // must be called on a float T\r\n    if (!isFloat(actual))\r\n      ERROR(\"toBeCloseTo must be called with a Float value type T.\");\r\n    Actual.report(actual);\r\n    Expected.report(expected, negated);\r\n\r\n    // both actual and expected values must be finite\r\n    assert(\r\n      i32(isFinite(actual)),\r\n      \"toBeCloseTo assertion fails because a actual value is not finite\",\r\n    );\r\n    assert(\r\n      i32(isFinite(expected)),\r\n      \"toBeCloseTo assertion fails because expected value is not finite.\",\r\n    );\r\n\r\n    // calculated: `|expected - actual| < 1 / numberOfDigits`.\r\n    // @ts-ignore tooling errors because T does not extend a numeric value type. This compiles just fine.\r\n    let isClose = i32(abs(expected - actual) < Math.pow(0.1, decimalPlaces));\r\n    assert(negated ^ isClose, message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toBeNaN(message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    let negated = this._not;\r\n\r\n    // must be called on a float T\r\n    if (!isFloat(actual))\r\n      ERROR(\"toBeNaN must be called with a Float value type T.\");\r\n    Actual.report(actual);\r\n\r\n    // @ts-ignore: The compiler should pass bit count (64/32 bit float to the report function)\r\n    Expected.report<T>(NaN, negated);\r\n\r\n    let isNaNValue = i32(isNaN(actual));\r\n    assert(isNaNValue ^ negated, message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toBeFinite(message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    let negated = this._not;\r\n\r\n    // must be called on a float T\r\n    if (!isFloat(actual))\r\n      ERROR(\"toBeNaN must be called with a Float value type T.\");\r\n    Actual.report(actual);\r\n    Expected.reportFinite(negated);\r\n\r\n    let isFiniteValue = i32(isFinite(actual));\r\n    assert(isFiniteValue ^ negated, message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toHaveLength(expected: i32, message: string = \"\"): void {\r\n    let actual = this.actual;\r\n    let negated = this._not;\r\n    let length = 0;\r\n    if (actual instanceof ArrayBuffer) {\r\n      length = actual.byteLength;\r\n    } else {\r\n      // @ts-ignore: This results in a compile time check for a length property with a better error message\r\n      if (!isDefined(actual.length))\r\n        ERROR(\r\n          \"toHaveLength cannot be called on type T where T.length is not defined.\",\r\n        );\r\n      // @ts-ignore: This results in a compile time check for a length property with a better error message\r\n      length = <i32>actual.length;\r\n    }\r\n\r\n    Actual.report(length);\r\n    Expected.report(expected, negated);\r\n\r\n    let lengthsEqual = i32(length == expected);\r\n    assert(lengthsEqual ^ negated, message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toInclude<U>(expected: U, message: string = \"\"): void {\r\n    toIncludeComparison<T, U>(this.actual, expected, this._not, message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  // @ts-ignore: valueof<T> requires that T extends something with an @operator(\"[]\")\r\n  public toContain(expected: valueof<T>, message: string = \"\"): void {\r\n    this.toInclude(expected, message);\r\n  }\r\n\r\n  public toIncludeEqual<U>(expected: U, message: string = \"\"): void {\r\n    toIncludeEqualComparison<T, U>(this.actual, expected, this._not, message);\r\n    Actual.clear();\r\n    Expected.clear();\r\n  }\r\n\r\n  public toContainEqual<U>(expected: U, message: string = \"\"): void {\r\n    this.toIncludeEqual(expected, message);\r\n  }\r\n\r\n  public toMatchSnapshot(name: string | null = null): void {\r\n    assert(i32(!this._not), \"Snapshots cannot be negated.\");\r\n    Expected.reportSnapshot(this.actual, name);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorators *are* valid here\r\n@global\r\nexport function expect<T>(actual: T): Expectation<T> {\r\n  return new Expectation(actual);\r\n}\r\n\r\n// @ts-ignore: decorators *are* valid here\r\n@global\r\nexport function expectFn(cb: () => void): Expectation<() => void> {\r\n  WARNING(\"expectFn() has been deprecated. Use expect() instead.\");\r\n  return new Expectation(cb);\r\n}\r\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { OBJECT, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ptr: usize, classId: u32): bool { // keyword\n  var id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;\n  var rttiBase = __rtti_base;\n  if (id <= load<u32>(rttiBase)) {\n    do if (id == classId) return true;\n    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  var buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  var buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  var array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare var __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n;\n    store<u8>(dest, c);\n    store<u8>(dend - 1, c);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend - 2, c);\n    store<u8>(dend - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n;\n    store<u32>(dest, c32);\n    store<u32>(dend - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend - 12, c32);\n    store<u32>(dend - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend - 28, c32);\n    store<u32>(dend - 24, c32);\n    store<u32>(dend - 20, c32);\n    store<u32>(dend - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","// @ts-ignore: Decorators *are* valid here!\r\n@external(\"__aspect\", \"reportActualReflectedValue\")\r\ndeclare function reportActualReflectedValue(id: i32): void;\r\n\r\n// @ts-ignore: Decorators *are* valid here!\r\n@external(\"__aspect\", \"clearActual\")\r\ndeclare function clearActual(): void;\r\n\r\n@global\r\nexport class Actual {\r\n  static report<T>(actual: T): void {\r\n    let value = Reflect.toReflectedValue(actual);\r\n    Reflect.attachStackTrace(value);\r\n    reportActualReflectedValue(value);\r\n  }\r\n\r\n  static clear(): void {\r\n    clearActual();\r\n  }\r\n}\r\n","import { ArrayBufferView } from \"arraybuffer\";\r\nimport { Set } from \"set\";\r\nimport { assert } from \"./assert\";\r\nimport { ReflectedValueType } from \"./ReflectedValueType\";\r\nimport { OBJECT, OBJECT_OVERHEAD } from \"rt/common\";\r\n\r\nfunction pairSeen(a1: usize, a2: usize, b1: usize, b2: usize): bool {\r\n  return bool(\r\n    (i32(a1 == b1) & i32(a2 == b2)) | (i32(a1 == b2) & i32(a2 == b1)),\r\n  );\r\n}\r\n\r\n// @ts-ignore: Decorators *are* valid here!\r\n@external(\"__aspect\", \"attachStackTraceToReflectedValue\")\r\ndeclare function attachStackTraceToReflectedValue(id: i32): void;\r\n\r\n// @ts-ignore: linked function decorator\r\n@external(\"__aspect\", \"createReflectedValue\")\r\ndeclare function createReflectedValue(\r\n  isNull: bool,\r\n  hasKeys: bool,\r\n  nullable: bool,\r\n  offset: i32,\r\n  pointer: usize,\r\n  signed: bool,\r\n  size: i32,\r\n  reflectedTypeValue: ReflectedValueType,\r\n  typeId: i32,\r\n  typeName: string,\r\n  value: usize,\r\n  hasValues: bool,\r\n  isManaged: bool,\r\n): i32;\r\n\r\n// @ts-ignore: linked function decorator\r\n@external(\"__aspect\", \"createReflectedNumber\")\r\ndeclare function createReflectedNumber(\r\n  signed: bool,\r\n  size: i32,\r\n  reflectedTypeValue: ReflectedValueType,\r\n  typeName: string,\r\n  value: f64,\r\n): i32;\r\n\r\n// @ts-ignore: linked function decorator\r\n@external(\"__aspect\", \"createReflectedLong\")\r\ndeclare function createReflectedLong(\r\n  signed: bool,\r\n  size: i32,\r\n  reflectedTypeValue: ReflectedValueType,\r\n  typeName: string,\r\n  lowValue: i32,\r\n  highValue: i32,\r\n): i32;\r\n\r\n// @ts-ignore: external declaration\r\n@external(\"__aspect\", \"pushReflectedObjectValue\")\r\n@global\r\ndeclare function __aspectPushReflectedObjectValue(\r\n  parentID: i32,\r\n  value: i32,\r\n): void;\r\n\r\n// @ts-ignore: external declaration\r\n@external(\"__aspect\", \"pushReflectedObjectKey\")\r\n@global\r\ndeclare function __aspectPushReflectedObjectKey(\r\n  parentID: i32,\r\n  value: i32,\r\n): void;\r\n\r\n@inline function sizeOf(ptr: usize): i32 {\r\n  return changetype<OBJECT>(ptr - OBJECT_OVERHEAD).rtSize;\r\n}\r\n\r\n@global\r\n// @ts-ignore: global decorator is allowed here\r\nexport class Reflect {\r\n  public static toReflectedValue<T>(\r\n    value: T,\r\n    seen: Map<usize, i32> = new Map<usize, i32>(),\r\n  ): i32 {\r\n    // if T is a reference\r\n    if (isReference<T>()) {\r\n      // if the value is null, create a Null reflected value\r\n      if (changetype<usize>(value) == 0) {\r\n        return createReflectedValue(\r\n          true,\r\n          false,\r\n          isNullable<T>(),\r\n          0,\r\n          0,\r\n          false,\r\n          sizeof<T>(),\r\n          isFunction<T>()\r\n            ? ReflectedValueType.Function\r\n            : ReflectedValueType.Class,\r\n          isManaged<T>() ? idof<T>() : 0,\r\n          isFunction<T>() ? \"Function\" : nameof<T>(),\r\n          0,\r\n          false,\r\n          isManaged<T>(),\r\n        );\r\n      }\r\n\r\n      // check the cache for anything that isn't a function\r\n      if (!isFunction<T>()) {\r\n        if (seen.has(changetype<usize>(value))) {\r\n          return seen.get(changetype<usize>(value));\r\n        }\r\n      }\r\n\r\n      // @ts-ignore: __aspectReflectAs() can potentially be implemented\r\n      if (isDefined(value.__aspectReflectAs())) {\r\n        // @ts-ignore: typesafe call to __aspectReflectAs()\r\n        let displayValue = value.__aspectReflectAs();\r\n        if (\r\n          !isInteger(displayValue) &&\r\n          !isFloat(displayValue) &&\r\n          !isManaged(displayValue)\r\n        ) {\r\n          ERROR(\r\n            \"__aspectReflectAs() function should return a managed type or a number\",\r\n          );\r\n        }\r\n        return Reflect.toReflectedValue(displayValue, seen);\r\n      }\r\n\r\n      if (value instanceof ArrayBuffer) {\r\n        let reflectedValue = createReflectedValue(\r\n          false,\r\n          false,\r\n          isNullable<T>(),\r\n          value.byteLength,\r\n          changetype<usize>(value),\r\n          false,\r\n          value.byteLength,\r\n          ReflectedValueType.ArrayBuffer,\r\n          idof<T>(),\r\n          nameof<T>(),\r\n          0,\r\n          true,\r\n          true,\r\n        );\r\n        seen.set(changetype<usize>(value), reflectedValue);\r\n        let length = value.byteLength;\r\n        for (let i = 0; i < length; i++) {\r\n          __aspectPushReflectedObjectValue(\r\n            reflectedValue,\r\n            Reflect.toReflectedValue(\r\n              load<u8>(changetype<usize>(value) + <usize>i),\r\n              seen,\r\n            ),\r\n          );\r\n        }\r\n        return reflectedValue;\r\n      } else if (isFunction<T>()) {\r\n        let func = value;\r\n        let reflectedValue = createReflectedValue(\r\n          false,\r\n          false,\r\n          isNullable<T>(),\r\n          0,\r\n          // @ts-ignore has field\r\n          func.index,\r\n          false,\r\n          0,\r\n          ReflectedValueType.Function,\r\n          0,\r\n          \"Function\",\r\n          // @ts-ignore has field\r\n          func.index,\r\n          false,\r\n          isManaged<T>(),\r\n        );\r\n        return reflectedValue;\r\n      } else if (value instanceof Set) {\r\n        // create a Set reflected value\r\n        let reflectedObject = createReflectedValue(\r\n          false,\r\n          false, // sets don't have keys\r\n          isNullable<T>(),\r\n          0,\r\n          changetype<usize>(value),\r\n          false,\r\n          value.size,\r\n          ReflectedValueType.Set,\r\n          idof<T>(),\r\n          nameof<T>(),\r\n          0,\r\n          true, // sets have values\r\n          true,\r\n        );\r\n\r\n        // cache this value\r\n        seen.set(changetype<usize>(value), reflectedObject);\r\n\r\n        // loop over each item and push it to the Set\r\n        let values = value.values();\r\n        let length = values.length;\r\n        for (let i = 0; i < length; i++) {\r\n          let value = unchecked(values[i]);\r\n          let reflectedValueID = Reflect.toReflectedValue(value, seen);\r\n          __aspectPushReflectedObjectValue(reflectedObject, reflectedValueID);\r\n        }\r\n      } else if (value instanceof Map) {\r\n        // create a Set reflected object\r\n        let reflectedValue = createReflectedValue(\r\n          false,\r\n          true, // maps have keys\r\n          isNullable<T>(),\r\n          0,\r\n          changetype<usize>(value),\r\n          false,\r\n          value.size,\r\n          ReflectedValueType.Map,\r\n          idof<T>(),\r\n          nameof<T>(),\r\n          0,\r\n          true, // maps have values\r\n          true,\r\n        );\r\n\r\n        // cache this value\r\n        seen.set(changetype<usize>(value), reflectedValue);\r\n\r\n        // loop over each key and push the key value pair to the reflected Map\r\n        let keys = value.keys();\r\n        let length = keys.length;\r\n        for (let i = 0; i < length; i++) {\r\n          let mapKey = unchecked(keys[i]);\r\n          let reflectedKeyID = Reflect.toReflectedValue(mapKey, seen);\r\n          __aspectPushReflectedObjectKey(reflectedValue, reflectedKeyID);\r\n\r\n          let mapValue = value.get(mapKey);\r\n          let reflectedValueID = Reflect.toReflectedValue(mapValue, seen);\r\n          __aspectPushReflectedObjectValue(reflectedValue, reflectedValueID);\r\n        }\r\n\r\n        return reflectedValue;\r\n      } else if (value instanceof ArrayBufferView) {\r\n        // @ts-ignore: has field\r\n        let length = value.length;\r\n\r\n        // create an arraylike reflected value\r\n        let reflectedValue = createReflectedValue(\r\n          false,\r\n          false, // arrays don't have keys\r\n          isNullable<T>(),\r\n          0,\r\n          changetype<usize>(value),\r\n          false,\r\n          length,\r\n          value instanceof Array\r\n            ? ReflectedValueType.Array\r\n            : ReflectedValueType.TypedArray,\r\n          idof<T>(),\r\n          nameof<T>(),\r\n          0,\r\n          true, // maps have values\r\n          isManaged<T>(),\r\n        );\r\n\r\n        // cache this value\r\n        seen.set(changetype<usize>(value), reflectedValue);\r\n\r\n        // loop over each value and push it to the reflected value\r\n        for (let i = 0; i < length; i++) {\r\n          // @ts-ignore index signature is garunteed at this point\r\n          let arrayValue = unchecked(value[i]);\r\n          let reflectedArrayValueID = Reflect.toReflectedValue(\r\n            arrayValue,\r\n            seen,\r\n          );\r\n          __aspectPushReflectedObjectValue(\r\n            reflectedValue,\r\n            reflectedArrayValueID,\r\n          );\r\n        }\r\n\r\n        return reflectedValue;\r\n      } else if (value instanceof String) {\r\n        let reflectedStringID = createReflectedValue(\r\n          false,\r\n          false,\r\n          isNullable<T>(),\r\n          0,\r\n          changetype<usize>(value),\r\n          false,\r\n          value.length,\r\n          ReflectedValueType.String,\r\n          idof<T>(),\r\n          nameof<T>(),\r\n          changetype<usize>(value),\r\n          false,\r\n          true,\r\n        );\r\n        seen.set(changetype<usize>(value), reflectedStringID);\r\n        return reflectedStringID;\r\n      } else if (isArrayLike<T>()) {\r\n        // @ts-ignore: arraylike has length property\r\n        let length = <i32>value.length;\r\n\r\n        // create an arraylike reflected value\r\n        let reflectedValue = createReflectedValue(\r\n          false,\r\n          false, // arrays don't have keys\r\n          isNullable<T>(),\r\n          0,\r\n          changetype<usize>(value),\r\n          false,\r\n          length,\r\n          ReflectedValueType.Array,\r\n          isManaged<T>() ? idof<T>() : 0,\r\n          nameof<T>(),\r\n          0,\r\n          true, // maps have values\r\n          isManaged<T>(),\r\n        );\r\n\r\n        // cache this value\r\n        seen.set(changetype<usize>(value), reflectedValue);\r\n\r\n        // loop over each array item and push it to the reflected value\r\n        for (let i = 0; i < length; i++) {\r\n          // @ts-ignore: index signature in arraylike\r\n          let arrayValue = unchecked(value[i]);\r\n          let reflectedArrayValueID = Reflect.toReflectedValue(\r\n            arrayValue,\r\n            seen,\r\n          );\r\n          __aspectPushReflectedObjectValue(\r\n            reflectedValue,\r\n            reflectedArrayValueID,\r\n          );\r\n        }\r\n        return reflectedValue;\r\n      } else {\r\n        // generic class\r\n        let reflectedObjectID = createReflectedValue(\r\n          false,\r\n          true, // classes have keys\r\n          isNullable<T>(),\r\n          offsetof<T>(),\r\n          changetype<usize>(value),\r\n          false,\r\n          sizeOf(changetype<usize>(value)),\r\n          ReflectedValueType.Class,\r\n          isManaged<T>() ? idof<T>() : 0,\r\n          nameof<T>(),\r\n          0,\r\n          true, // classes have values\r\n          isManaged<T>(),\r\n        );\r\n\r\n        // cache this object\r\n        seen.set(changetype<usize>(value), reflectedObjectID);\r\n\r\n        // @ts-ignore: __aspectAddReflectedValueKeyValuePairs is auto-generated by the transform\r\n        value.__aspectAddReflectedValueKeyValuePairs(\r\n          reflectedObjectID,\r\n          seen,\r\n          [] as StaticArray<i64>,\r\n        );\r\n\r\n        return reflectedObjectID;\r\n      }\r\n    } else if (alignof<T>() === 3 && isInteger<T>()) {\r\n      // u64, i64, isize, or usize (when targeting 64 bit WebAssembly)\r\n      // @ts-ignore: value is a number\r\n      let reflectedValue = createReflectedLong(\r\n        isSigned<T>(),\r\n        sizeof<T>(),\r\n        ReflectedValueType.Integer,\r\n        nameof<T>(),\r\n        // @ts-ignore: value is a 64 bit number\r\n        <i32>(value & 0xffffffff),\r\n        // @ts-ignore: value is a 64 bit number\r\n        <i32>(value >>> 32),\r\n      );\r\n\r\n      return reflectedValue;\r\n    } else {\r\n      // boolean, i32, u32, f32, isize, usize (when targeting 32 bit WebAssembly), or numbers with less bits\r\n      let reflectedValue = createReflectedNumber(\r\n        isSigned<T>(),\r\n        sizeof<T>(),\r\n        isBoolean<T>()\r\n          ? ReflectedValueType.Boolean\r\n          : isInteger<T>()\r\n          ? ReflectedValueType.Integer\r\n          : ReflectedValueType.Float,\r\n        nameof<T>(),\r\n        // @ts-ignore: type is bool, i32, f64, or f32\r\n        <f64>value,\r\n      );\r\n      return reflectedValue;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  public static equals<T>(\r\n    left: T,\r\n    right: T,\r\n    stack: usize[] = [],\r\n    cache: usize[] = [],\r\n  ): i32 {\r\n    // use `==` operator to work with operator overloads and strings\r\n    if (left == right) return Reflect.SUCCESSFUL_MATCH; // works immutably for string comparison\r\n\r\n    // floats should equal each other\r\n    if (isFloat<T>()) {\r\n      if (i32(isNaN(left)) & i32(isNaN(right))) return Reflect.SUCCESSFUL_MATCH;\r\n    }\r\n\r\n    if (isReference<T>()) {\r\n      // T can always be null if it's a reference, emit a runtime check for it regardless of type\r\n      if (\r\n        i32(changetype<usize>(left) == 0) ^ i32(changetype<usize>(right) == 0)\r\n      ) {\r\n        return Reflect.FAILED_MATCH;\r\n      }\r\n    }\r\n\r\n    // check every reference that isn't a function reference\r\n    if (isReference<T>() && !isFunction<T>()) {\r\n      if (isNullable<T>()) {\r\n        return referencesEqual(left!, right!, stack, cache);\r\n      } else {\r\n        return referencesEqual(left, right, stack, cache);\r\n      }\r\n    } else {\r\n      // value type, and strict equality cannot be asserted\r\n      return Reflect.FAILED_MATCH;\r\n    }\r\n  }\r\n\r\n  public static attachStackTrace(id: i32): void {\r\n    attachStackTraceToReflectedValue(id);\r\n  }\r\n}\r\n\r\nfunction referencesEqual<T>(\r\n  left: T,\r\n  right: T,\r\n  stack: usize[],\r\n  cache: usize[],\r\n): i32 {\r\n  let a = changetype<usize>(left);\r\n  let b = changetype<usize>(right);\r\n\r\n  let cacheLength = cache.length;\r\n  // must be EVEN or there's a big problem\r\n  assert(i32((cacheLength & 0x00000001) == 0), \"cacheLength should be even\");\r\n\r\n  // short circuit for strings\r\n  if (left instanceof String) {\r\n    return Reflect.FAILED_MATCH;\r\n  }\r\n\r\n  // check the cache for matched pairs\r\n  for (let i = 0; i < cacheLength; i += 2) {\r\n    if (pairSeen(a, b, unchecked(cache[i]), unchecked(cache[i + 1])))\r\n      return Reflect.SUCCESSFUL_MATCH;\r\n  }\r\n\r\n  // short circuit because this pair might already be resolving\r\n  let length = stack.length;\r\n  for (let i = 0; i < length; i += 2) {\r\n    if (pairSeen(a, b, unchecked(stack[i]), unchecked(stack[i + 1])))\r\n      return Reflect.DEFER_MATCH;\r\n  }\r\n\r\n  // once we've determined we need to check the references for their values, arraybuffers\r\n  // require a memory compare\r\n  if (left instanceof ArrayBuffer) {\r\n    // @ts-ignore: typesafe access to byteLength property because T is ArrayBuffer\r\n    if (left.byteLength != right.byteLength) return Reflect.FAILED_MATCH;\r\n    let result = memory.compare(a, b, left.byteLength);\r\n    if (result == 0) {\r\n      cache.push(a);\r\n      cache.push(b);\r\n      return Reflect.SUCCESSFUL_MATCH;\r\n    } else return Reflect.FAILED_MATCH;\r\n  }\r\n\r\n  // @ts-ignore: valid index signature check\r\n  if (isDefined(left[0])) {\r\n    // test for safe indexof usage\r\n    // set match\r\n    if (left instanceof Set) {\r\n      // @ts-ignore: size is a valid property of Set\r\n      if (left.size != right.size) return Reflect.FAILED_MATCH;\r\n      stack.push(a);\r\n      stack.push(b);\r\n      // @ts-ignore: values() is a valid function of Set\r\n      let leftValues = left.values();\r\n      // @ts-ignore: values() is a valid function of Set\r\n      let rightValues = right.values();\r\n      let length = leftValues.length;\r\n      let leftoverLength = length;\r\n      for (let i = 0; i < length; i++) {\r\n        let leftItem = unchecked(leftValues[i]);\r\n        let continueOuter = false;\r\n        for (let j = 0; j < leftoverLength; j++) {\r\n          let rightItem = unchecked(rightValues[j]);\r\n          if (\r\n            Reflect.equals(leftItem, rightItem, stack, cache) !=\r\n            Reflect.FAILED_MATCH\r\n          ) {\r\n            rightValues.splice(j, 1);\r\n            leftoverLength--;\r\n            continueOuter = true;\r\n            break;\r\n          }\r\n        }\r\n        if (continueOuter) continue;\r\n\r\n        stack.pop();\r\n        stack.pop();\r\n        return Reflect.FAILED_MATCH;\r\n      }\r\n\r\n      cache.push(a);\r\n      cache.push(b);\r\n\r\n      stack.pop();\r\n      stack.pop();\r\n      return Reflect.SUCCESSFUL_MATCH;\r\n    }\r\n\r\n    if (left instanceof Map) {\r\n      // @ts-ignore: size is a valid property of Map\r\n      if (left.size != right.size) return Reflect.FAILED_MATCH;\r\n      stack.push(a);\r\n      stack.push(b);\r\n\r\n      // collect all the keys and loop over each one\r\n      let leftKeys = left.keys();\r\n      // @ts-ignore: keys() is a valid function of Map\r\n      let rightKeys = right.keys();\r\n\r\n      // @ts-ignore: length is a valid property of Array\r\n      let keyLength = leftKeys.length;\r\n      let leftoverKeyLength = keyLength;\r\n\r\n      // assume we match and determine if the match was a failure\r\n      let result = Reflect.SUCCESSFUL_MATCH;\r\n\r\n      // for each key\r\n      for (let i = 0; i < keyLength; i++) {\r\n        let leftKey = unchecked(leftKeys[i]);\r\n        // assume won't find it\r\n        let found = false;\r\n\r\n        // find a matching key\r\n        for (let j = 0; j < leftoverKeyLength; j++) {\r\n          let rightKey = unchecked(rightKeys[j]);\r\n\r\n          // if the keys match, or are still being resolved\r\n          if (\r\n            Reflect.equals(leftKey, rightKey, stack, cache) !=\r\n            Reflect.FAILED_MATCH\r\n          ) {\r\n            // the key potentially matches, obtain the values associated with the keys\r\n            let leftValue = left.get(leftKey);\r\n            // @ts-ignore: get() is a valid function of Map\r\n            let rightValue = right.get(rightKey);\r\n\r\n            // if the values match, or are still being resolved\r\n            if (\r\n              Reflect.equals(leftValue, rightValue, stack, cache) !=\r\n              Reflect.FAILED_MATCH\r\n            ) {\r\n              leftoverKeyLength--;\r\n              rightKeys.splice(j, 1); // remove this key from the list\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // if there was no match for this key value pair, the result is Failed\r\n        if (!found) {\r\n          result = Reflect.FAILED_MATCH;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // if every key matched, result is still equal to `Reflect.MATCH`\r\n      if (result == Reflect.SUCCESSFUL_MATCH) {\r\n        cache.push(a);\r\n        cache.push(b);\r\n      }\r\n\r\n      stack.pop();\r\n      stack.pop();\r\n      return result;\r\n    }\r\n\r\n    // compile time array values should be compared over a for loop\r\n    // @ts-ignore: typesafe access to length\r\n    if (isDefined(left.length)) {\r\n      // @ts-ignore: typesafe access to length\r\n      let aLength = left.length;\r\n      // @ts-ignore: typesafe access to length\r\n      let bLength = right.length;\r\n\r\n      // assert the lengths are good\r\n      if (aLength != bLength) return Reflect.FAILED_MATCH;\r\n\r\n      // check each item\r\n      for (let i = 0; i < aLength; i++) {\r\n        let result = Reflect.equals(\r\n          // @ts-ignore: typesafe and runtime check safe array access\r\n          unchecked(left[i]),\r\n          // @ts-ignore: typesafe and runtime check safe array access\r\n          unchecked(right[i]),\r\n          stack,\r\n          cache,\r\n        );\r\n        if (result == Reflect.FAILED_MATCH) return Reflect.FAILED_MATCH;\r\n      }\r\n\r\n      // cache this result\r\n      cache.push(a);\r\n      cache.push(b);\r\n\r\n      return Reflect.SUCCESSFUL_MATCH;\r\n    }\r\n  }\r\n\r\n  // todo: handle Set<keyof<T>> and Map<keyof<T>, valueof<T>>\r\n\r\n  // we are trying to resolve this pair, push it to the stack\r\n  stack.push(a);\r\n  stack.push(b);\r\n\r\n  let result = false;\r\n  // @ts-ignore: __aspectStrictEquals is defined at this point\r\n  result = (isNullable(left) ? left! : left).__aspectStrictEquals(\r\n    right,\r\n    stack,\r\n    cache,\r\n    [] as StaticArray<i64>,\r\n  );\r\n\r\n  if (result) {\r\n    cache.push(a);\r\n    cache.push(b);\r\n  }\r\n\r\n  stack.pop();\r\n  stack.pop();\r\n  return select(Reflect.SUCCESSFUL_MATCH, Reflect.FAILED_MATCH, result);\r\n}\r\n\r\nexport namespace Reflect {\r\n  export const FAILED_MATCH = 0;\r\n  export const SUCCESSFUL_MATCH = 1;\r\n  export const DEFER_MATCH = 2;\r\n}\r\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (key === null) return XXH32_SEED;\n\n  var h: u32 = key.length << 1;\n  var len: usize = h;\n  var pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  var end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\n\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a set entry. */\n@unmanaged class SetEntry<K> {\n  key: K;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<T>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\n  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<T>(): usize {\n  const align = ENTRY_ALIGN<T>();\n  const size = (offsetof<SetEntry<T>>() + align) & ~align;\n  return size;\n}\n\nexport class Set<T> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, SetEntry<K>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: T, hashCode: u32): SetEntry<T> | null {\n    var entry = load<SetEntry<T>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  @operator(\"[]\")\n  has(key: T): bool {\n    return this.find(key, HASH<T>(key)) !== null;\n  }\n\n  add(key: T): this {\n    var hashCode = HASH<T>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (!entry) {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());\n      entry.key = key;\n      if (isManaged<T>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  @operator(\"[]=\")\n  private __set(key: T, value: bool): void {\n    if (value) this.add(key);\n    else this.delete(key);\n  }\n\n  delete(key: T): bool {\n    var entry = this.find(key, HASH<T>(key)); // unmanaged!\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<T>();\n      }\n      oldPtr += ENTRY_SIZE<T>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  values(): T[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<T>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.key;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Set]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<T>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n      while (cur < end) {\n        let entry = changetype<SetEntry<T>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          let val = changetype<usize>(entry.key);\n          if (isNullable<T>()) {\n            if (val) __visit(val, cookie);\n          } else __visit(val, cookie);\n        }\n        cur += ENTRY_SIZE<T>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","export const enum ReflectedValueType {\r\n  None = 0,\r\n  Class = 1,\r\n  String = 2,\r\n  ArrayBuffer = 3,\r\n  Map = 4,\r\n  Set = 5,\r\n  Function = 6,\r\n  Integer = 7,\r\n  Float = 8,\r\n  Boolean = 9,\r\n  Array = 10,\r\n  TypedArray = 11,\r\n  Finite = 12,\r\n  Truthy = 13,\r\n  Falsy = 14,\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (value === null) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) !== null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var keys = new Array<K>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        keys[length++] = entry.key;\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<V>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.value;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","// @ts-ignore: Decorators *are* valid here!\r\n@external(\"__aspect\", \"reportExpectedReflectedValue\")\r\ndeclare function reportExpectedReflectedValue(id: i32, negated: i32): void;\r\n\r\n// @ts-ignore: Decorators *are* valid here!\r\n@external(\"__aspect\", \"reportExpectedSnapshot\")\r\ndeclare function reportExpectedSnapshot(id: i32, name: string | null): void;\r\n\r\n// @ts-ignore: Decorators *are* valid here!\r\n@external(\"__aspect\", \"reportExpectedTruthy\")\r\ndeclare function reportExpectedTruthy(negated: i32): void;\r\n\r\n// @ts-ignore: Decorators *are* valid here!\r\n@external(\"__aspect\", \"reportExpectedFalsy\")\r\ndeclare function reportExpectedFalsy(negated: i32): void;\r\n\r\n// @ts-ignore: Decorators *are* valid here!\r\n@external(\"__aspect\", \"reportExpectedFinite\")\r\ndeclare function reportExpectedFinite(negated: i32): void;\r\n\r\n// @ts-ignore: Decorators *are* valid here!\r\n@external(\"__aspect\", \"clearExpected\")\r\ndeclare function clearExpected(): void;\r\n\r\n@global\r\nexport class Expected {\r\n  static report<T>(expected: T, negated: i32 = 0): void {\r\n    let value = Reflect.toReflectedValue(expected);\r\n    Reflect.attachStackTrace(value);\r\n    reportExpectedReflectedValue(value, negated);\r\n  }\r\n\r\n  static reportTruthy(negated: i32 = 0): void {\r\n    reportExpectedTruthy(negated);\r\n  }\r\n\r\n  static reportFalsy(negated: i32 = 0): void {\r\n    reportExpectedFalsy(negated);\r\n  }\r\n\r\n  static reportFinite(negated: i32 = 0): void {\r\n    reportExpectedFinite(negated);\r\n  }\r\n\r\n  static reportSnapshot<T>(actual: T, name: string | null = null): void {\r\n    reportExpectedSnapshot(\r\n      Reflect.toReflectedValue(actual, new Map<usize, i32>()),\r\n      name,\r\n    );\r\n  }\r\n\r\n  static clear(): void {\r\n    clearExpected();\r\n  }\r\n}\r\n","export function assert(condition: i32, message: string): void {\r\n  if (!condition) throw new Error(message);\r\n}\r\n","/*  eslint-disable */\r\nexport const noOp = (): void => {};\r\n","// @ts-ignore: decorators *are* valid here\r\n@external(\"__aspect\", \"logReflectedValue\")\r\ndeclare function logReflectedValue(value: i32): void;\r\n\r\nlet ignoreLogs: bool = false;\r\n\r\nexport function __ignoreLogs(value: bool): void {\r\n  ignoreLogs = value;\r\n}\r\n\r\n// @ts-ignore: decorators *are* valid here\r\n@global\r\nexport function log<T>(value: T): void {\r\n  if (ignoreLogs) return;\r\n  let reflectedId = Reflect.toReflectedValue(value);\r\n  Reflect.attachStackTrace(reflectedId);\r\n  logReflectedValue(reflectedId);\r\n}\r\n","export function __call(func: () => void): void {\r\n  func();\r\n}\r\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}